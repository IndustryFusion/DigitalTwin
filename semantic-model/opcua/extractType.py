#!/usr/bin/env python3
#
# Copyright (c) 2024 Intel Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import sys
import urllib
import lib.jsonld as libjsonld
from lib.utils import warnings, print_warning
from collections import defaultdict
from rdflib import Graph, Namespace, URIRef
from rdflib.namespace import OWL, RDF, SH
import argparse
import lib.utils as utils
from lib.utils import RdfUtils, OntologyLoader, NULL_IRI
from lib.bindings import Bindings
from lib.jsonld import JsonLd
from lib.entity import Entity
from lib.shacl import Shacl

warnings.filterwarnings("ignore", message=".*anyType is not defined in namespace XSD.*")
attribute_prefix = utils.ATTRIBUTE_PREFIX
default_context_url = "https://industryfusion.github.io/contexts/staging/opcua/v0.2/context.jsonld"

query_namespaces = """
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
SELECT ?uri ?prefix ?ns WHERE {
    ?ns rdf:type base:Namespace .
    ?ns base:hasUri ?uri .
    ?ns base:hasPrefix ?prefix .
}
"""

query_subclasses = """
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

CONSTRUCT {
  ?subclass rdfs:subClassOf ?superclass .
  ?subclass a owl:Class .
  ?superclass a owl:Class .
}
WHERE {
  ?subclass rdfs:subClassOf* <http://opcfoundation.org/UA/BaseObjectType> .
  ?subclass rdfs:subClassOf ?superclass .

  # Ensure both subclasses and superclasses are marked as owl:Class
  {
    ?subclass a owl:Class .
  } UNION {
    ?superclass a owl:Class .
  }
}
"""


randnamelength = 16
modelling_nodeid_optional = 80
modelling_nodeid_mandatory = 78
modelling_nodeid_optional_array = 11508
basic_types = [
    'String',
    'Boolean',
    'Byte',
    'SByte',
    'Int16',
    'UInt16',
    'Int32',
    'UInt32',
    'Uin64',
    'Int64',
    'Float',
    'DateTime',
    'Guid',
    'ByteString',
    'Double'
]
workaround_instances = [
    'http://opcfoundation.org/UA/DI/FunctionalGroupType',
    'http://opcfoundation.org/UA/FolderType'
]
datasetid_urn = 'urn:iff:datasetId'


def parse_args(args=sys.argv[1:]):
    parser = argparse.ArgumentParser(description='\
parse nodeset instance and create ngsi-ld model')

    parser.add_argument('instance', help='Path to the instance nodeset2 file.')
    parser.add_argument('-t', '--type',
                        help='Type of root object, e.g. http://opcfoundation.org/UA/Pumps/',
                        required=False)
    parser.add_argument('-j', '--jsonld',
                        help='Filename of jsonld output file',
                        required=False,
                        default='instances.jsonld')
    parser.add_argument('-e', '--entities',
                        help='Filename of entities output file',
                        required=False,
                        default='entities.ttl')
    parser.add_argument('-s', '--shacl',
                        help='Filename of SHACL output file',
                        required=False,
                        default='shacl.ttl')
    parser.add_argument('-b', '--bindings',
                        help='Filename of bindings output file',
                        required=False,
                        default='bindings.ttl')
    parser.add_argument('-c', '--context',
                        help='Filename of JSONLD context output file',
                        required=False,
                        default='context.jsonld')
    parser.add_argument('-d', '--debug',
                        help='Add additional debug info to structure (e.g. for better SHACL debug)',
                        required=False,
                        action='store_true')
    parser.add_argument('-mi', '--minimalshacl',
                        help='Remove all not monitored/updated shacl nodes',
                        required=False,
                        action='store_true')
    parser.add_argument('-ma', '--maximalshacl',
                        help='Add all types from nodes in the namespace.',
                        required=False,
                        action='store_true')
    parser.add_argument('-n', '--namespace', help='Namespace prefix for entities, SHACL and JSON-LD', required=True)
    parser.add_argument('-i', '--id',
                        help='ID prefix of object. The ID for every object is generated by "<prefix>:nodeId"',
                        required=False)
    parser.add_argument('-xe', '--entity-namespace',
                        help='Overwrite Namespace for entities (which is otherwise derived from <namespace>/entity)',
                        required=False)
    parser.add_argument('-xc', '--context-url', help=f'Context URL, default: {default_context_url}',
                        default=f"{default_context_url}",
                        required=False)
    parser.add_argument('-r', '--recursive-import',
                        help='Import dependencies of dependencies',
                        required=False,
                        default=False,
                        action='store_true')
    parser.add_argument('-sw', '--suppress-warnings', type=str, nargs='*',
                        help='List of Warnings which are to be suppressed.')
    parser.add_argument('-p', '--properties', help='Consider OPC UA Properties.', required=False, default=False,
                        action='store_true')
    parser.add_argument('-vrs', '--value-rank-subshapes', help='Add ValueRank subshapes (instead of nest '
                        'the whole expression).',
                        required=False, default=False,
                        action='store_true')

    parsed_args = parser.parse_args(args)
    return parsed_args


basens = None  # Will be defined by the imported ontologies
opcuans = None  # dito
ngsildns = Namespace('https://uri.etsi.org/ngsi-ld/')
scanned_types = set()
scanned_entities = set()


def check_object_consistency(shapenode, attribute_path, classtype, suppress_warnings=False, add_entity=True):
    """Check if attribute_path is already known.
       In this case, it is important to differentiate between FolderTypes and
       regular objects. For FolderType, we are relaxed, and search for common
       superclass to make sure objects stay compliant.
       If it is a regular object, then this means that the reference has already
       been found. What can happen is that there is a superclass with the same
       attribute_path but different classtype. This is only allowed when
       classtype of superclass is subclass of existing. Since the objecttypes are
       always scanned from special to general, it the superclass classtype must
       always fit.

    Args:
        shapenode (URIRef): SHACL shape node to compare with (node on which the constraints are defined)
        attribute_path (URIRef): property path which is questioned
        classtype (URIRef): sh:class of referenced object through property

    Returns:
        bool, URIRef: stop_scanning, common superclass if found
    """
    needed_superclass = None
    property = shaclg.get_property_from_shape(shapenode, attribute_path)
    instancetype = shaclg.get_targetclass(shapenode)
    if property is None:
        if add_entity and instancetype is not None:
            e.add_instancetype(instancetype, attribute_path)
            e.add_type(classtype)
        return False, None
    # Check if opcua:FolderType or its subclasses. This needs special treatment
    is_folder = utils.is_subclass(g, instancetype, opcuans['FolderType']) if instancetype is not None else False
    shclass = shaclg._get_shclass_from_property(property)
    if is_folder:
        if shclass != classtype:
            common_superclass = utils.get_common_supertype(g, shclass, classtype)
            shaclg.update_shclass_in_property(property, common_superclass)
            if not suppress_warnings:
                warnmsg = f"Class inconsistency found in (FolderType) \
    {instancetype}. The class {shclass} and {classtype} are defined for the same reference {attribute_path}."
            print_warning('folder_reference_inconsistency', warnmsg)
        return True, needed_superclass
    else:  # Normal Object
        # shclass must be subclass of classtype since we assume that classtype must come
        # from a superclass
        is_subclass = utils.is_subclass(g, shclass, classtype)
        if not is_subclass and not suppress_warnings:
            warnmsg = f"Class inconsistency found in shape {shapenode}. \
The class {shclass} must be subclass of {classtype} found in the hierarchy."
            print_warning('subclass_inconsistency', warnmsg)
        return True, None


def check_variable_consistency(shapenode, attribute_path, classtype):
    if shaclg.attribute_is_indomain(shapenode, attribute_path):
        return True
    instancetype = shaclg.get_targetclass(shapenode)
    if instancetype is not None:
        e.add_instancetype(instancetype, attribute_path)
    e.add_type(classtype)
    return False


def scan_type(node, instancetype, shape_node=None):

    # Loop through all supertypes
    supertypes = rdfutils.get_all_supertypes_and_interfaces(g, instancetype, node)
    # Loop through all components
    if shape_node is None:
        shapename = shaclg.create_shacl_type(instancetype)
    else:
        shapename = shape_node
    has_components = False
    for (curtype, curnode) in supertypes:
        children = rdfutils.get_all_subreferences(g, curnode, opcuans['HasChild'])
        for reference, target in children:
            if reference not in ignored_hierarchical_references:
                has_components = scan_type_recursive(target, curnode, instancetype, shapename,
                                                     reference) or has_components
        organizes = rdfutils.get_all_subreferences(g, curnode, opcuans['Organizes'])
        nonhierachical = rdfutils.get_all_subreferences(g, curnode, opcuans['NonHierarchicalReferences'])
        # Treat organizes like non-hierarchical references
        nonhierachical += organizes
        # Now group tuples after reference, i.e.
        # [(ref1, node1), (ref2, node2), (ref1, node2)] => [(ref1, [node1, node3]), (ref2, node2)]
        grouped = defaultdict(list)
        for key, value in nonhierachical:
            grouped[key].append(value)
        grouped_references = [(key, values) for key, values in grouped.items()]
        for generic_reference, target in grouped_references:
            if generic_reference not in ignored_references:
                has_components = scan_type_non_hierachical(target, curnode, instancetype, shapename,
                                                           generic_reference) or has_components
    return has_components


def scan_type_recursive(o, node, instancetype, shapename, reftype):

    shacl_rule = {}
    browse_name = next(g.objects(o, basens['hasBrowseName']))
    nodeclass, classtype = rdfutils.get_type(g, o)
    if nodeclass == opcuans['MethodNodeClass']:
        return False
    attributename = rdfutils.get_semantic_bridge(g, node, o)
    rdfutils.get_modelling_rule(g, o, shacl_rule, instancetype)

    placeholder_pattern = None
    decoded_attributename = urllib.parse.unquote(attributename)
    if utils.contains_both_angle_brackets(decoded_attributename):
        _, placeholder_pattern = utils.normalize_angle_bracket_name(browse_name)
    shacl_rule['path'] = attributename

    if rdfutils.isObjectNodeClass(nodeclass):
        stop_scan, _ = check_object_consistency(shapename, attributename, classtype)
        if stop_scan:
            return True
        # check for loop
        if (instancetype, node, o) in scanned_types:
            pnodeclass, _ = rdfutils.get_type(g, node)
            if rdfutils.isObjectTypeNodeClass(pnodeclass):
                return False
            print(f"Warning: Found already scanned node {node}=>{o} in hierarchical references. Could be potentially \
a loop.")
            return False
        else:
            scanned_types.add((instancetype, node, o))
        has_components = False
        shacl_rule['is_property'] = False
        _, use_instance_declaration = rdfutils.get_modelling_rule(g, o, None, instancetype)
        if use_instance_declaration:
            # This information mixes two details
            # 1. Use the instance declaration and not the object for instantiation
            # 2. It could be zero or more instances (i.e. and array)
            shacl_rule['array'] = True
            _, typeiri = rdfutils.get_type(g, o)
            try:
                typenode = next(g.subjects(basens['definesType'], typeiri))
                o = typenode
            except:
                pass
        components_found = scan_type(o, classtype)
        if maximal_shacl:
            components_found = True
        if components_found:
            has_components = True
            shacl_rule['contentclass'] = classtype
            shaclg.create_shacl_property(shapename,
                                         shacl_rule['path'],
                                         shacl_rule['optional'],
                                         shacl_rule['array'],
                                         False,
                                         True,
                                         shacl_rule['contentclass'],
                                         None,
                                         is_subcomponent=True,
                                         placeholder_pattern=placeholder_pattern,
                                         reftype=reftype)
    elif rdfutils.isVariableNodeClass(nodeclass):
        stop_scan = check_variable_consistency(shapename, attributename, classtype)
        if stop_scan:
            return True
        has_components = True
        try:
            isAbstract = utils.rdfStringToPythonBool(next(g.objects(classtype, basens['isAbstract'])))
        except:
            isAbstract = False
        if isAbstract:
            return False
        shacl_rule['is_property'] = True
        shaclg.get_shacl_iri_and_contentclass(g, o, node, shacl_rule)
        shacl_node = shaclg.create_shacl_property(shapename,
                                                  shacl_rule['path'],
                                                  shacl_rule['optional'],
                                                  shacl_rule['array'],
                                                  True, shacl_rule['is_iri'],
                                                  shacl_rule['contentclass'],
                                                  shacl_rule['datatype'],
                                                  pattern=shacl_rule['pattern'],
                                                  value_rank=shacl_rule.get('value_rank'),
                                                  array_dimensions=shacl_rule.get('array_dimensions'),
                                                  reftype=reftype)
        e.add_enum_class(g, shacl_rule['contentclass'])
        components_found = scan_type(o, classtype, shacl_node)
    return has_components


def scan_type_non_hierachical(target, node, instancetype, shapename, reftype):
    """scan non-hierarchical relationship

    Args:
        target (URIRef): targetnode
        node (URIRef): node containing the reference
        instancetype (URIRef): type for which the shacl constraint is defined
        shapename (URIRef): Name of SHACL Shape
        is_nh_reference (Bool): True for NH-references.
        reftype (URIRef): Reference name

    Returns:
        _type_: _description_
    """
    shacl_rule = {}
    # check if at least one object nodeclass is found
    full_attribute_name = reftype
    for t in target:
        nodeclass, _ = rdfutils.get_type(g, t)
        if not rdfutils.isVariableNodeClass(nodeclass):
            break

    if rdfutils.isObjectNodeClass(nodeclass) or rdfutils.isObjectTypeNodeClass(nodeclass):
        property = shaclg.get_property_from_shape(shapename, full_attribute_name)
        is_indomain = property is not None
        shclass = shaclg._get_shclass_from_property(property)
        for t in target:
            t_nodeclass, t_classtype = rdfutils.get_type(g, t)
            if rdfutils.isVariableNodeClass(t_nodeclass):
                warnmsg = f"Warning: Variable node {t} is target of \
non-owning or non-hierarchical reference {reftype} This will be ignored."
                print_warning('ignored_variable_reference', warnmsg)
                continue
            if shclass is None:
                shclass = t_classtype
            else:
                shclass = utils.get_common_supertype(g, shclass, t_classtype)
            check_object_consistency(shapename, full_attribute_name, shclass, not is_indomain, add_entity=False)
        if is_indomain:
            shaclg.update_shclass_in_property(full_attribute_name, shclass)
            return
        shacl_rule['path'] = full_attribute_name
        rdfutils.get_modelling_rule(g, t, shacl_rule, instancetype)
        e.add_instancetype(instancetype, full_attribute_name)
        e.add_type(shclass)
        maxcount = None

        shacl_rule['is_property'] = False
        shacl_rule['contentclass'] = shclass
        shaclg.create_shacl_property(shapename,
                                     shacl_rule['path'],
                                     shacl_rule['optional'],
                                     False,
                                     False,
                                     True,
                                     shacl_rule['contentclass'],
                                     None,
                                     reftype=reftype,
                                     maxCount=maxcount)
    elif rdfutils.isVariableNodeClass(nodeclass):
        warnmsg = f"Warning: Variable node {target} is target of \
non-owning or non-hierarchical reference {reftype} This will be ignored."
        print_warning('ignored_variable_reference', warnmsg)
    return


def scan_entity(node, instancetype, id, optional=False):
    node_id = rdfutils.generate_node_id(g, rootentity, node, id)
    # detect recursion
    if node_id in scanned_entities:
        return node_id

    instance = {}
    prefixed_type = utils.get_prefixed(context_graph, instancetype)
    instance['type'] = prefixed_type
    instance['id'] = node_id
    instance['@context'] = [
        context_url
    ]
    followed_nodes.add(node)

    # Loop through all components
    has_components = False
    children = rdfutils.get_all_subreferences(g, node, opcuans['HasChild'])
    for reference, target in children:
        if reference not in ignored_hierarchical_references:
            has_components = scan_entity_recursive(node, id, instance, node_id,
                                                   target, type=instancetype) or has_components
    organizes = rdfutils.get_all_subreferences(g, node, opcuans['Organizes'])
    for organizes_reference, target in organizes:
        has_components = scan_entity_nonrecursive(node, id, instance, node_id, target,
                                                  organizes_reference) or has_components
    non_hierarchicals = rdfutils.get_all_subreferences(g, node, opcuans['NonHierarchicalReferences'])
    for generic_reference, target in non_hierarchicals:
        if generic_reference not in ignored_references:
            has_components = scan_entity_nonrecursive(node, id, instance, node_id, target,
                                                      generic_reference) or has_components
    if has_components or not optional or maximal_shacl:
        jsonld.add_instance(instance)
        scanned_entities.add(node_id)
        return node_id
    else:
        return None


def scan_entity_variable(node, instancetype, id, optional=False):
    node_id = rdfutils.generate_node_id(g, rootentity, node, id)
    # detect recursion
    if node_id in scanned_entities:
        return node_id

    attributes = {}
    # Loop through all components
    has_components = False
    children = rdfutils.get_all_subreferences(g, node, opcuans['HasComponent'])
    for reference, target in children:
        has_components = scan_entity_recursive(node, id, attributes, node_id, target) or has_components
    children = rdfutils.get_all_subreferences(g, node, opcuans['HasProperty'])
    for reference, target in children:
        if reference not in ignored_hierarchical_references:
            has_components = scan_entity_recursive(node,
                                                   id,
                                                   attributes,
                                                   node_id,
                                                   target,
                                                   is_property=True) or has_components
    non_hierarchicals = rdfutils.get_all_subreferences(g, node, opcuans['NonHierarchicalReferences'])
    for generic_reference, target in non_hierarchicals:
        if generic_reference not in ignored_references:
            has_components = scan_entity_nonrecursive(node, id, attributes, node_id, target,
                                                      generic_reference) or has_components
    return attributes


def scan_entity_recursive(node, id, instance, node_id, o, type=None, is_property=False):
    has_components = False
    shacl_rule = {}
    browse_name = next(g.objects(o, basens['hasBrowseName']))
    nodeclass, classtype = rdfutils.get_type(g, o)
    attributename = rdfutils.get_semantic_bridge(g, node, o)

    original_attributename = None
    if type is not None:
        optional, array, path = shaclg.get_modelling_rule_and_path(browse_name, URIRef(type),
                                                                   classtype, attribute_prefix)
    else:
        optional, array, path = (None, None, None)
    if path is not None:
        original_attributename = urllib.parse.quote(browse_name)
        attributename = path
    shacl_rule['optional'] = optional
    shacl_rule['array'] = array
    datasetId = None

    try:
        expanded_type = utils.expand_term(context_graph, instance['type'])
        is_placeholder = shaclg.is_placeholder(expanded_type, attributename)
    except:
        is_placeholder = False
    if is_placeholder:
        if original_attributename is None:
            print(f"Warning: Cannot find proper match in SHACL description for placeholder value \
{attributename}. Will keep it with default datasetId. But it is very likely that the SHACL validation \
will flag this.")
            datasetId = "@none"
        else:
            datasetId = f'{datasetid_urn}:{original_attributename}'

    if rdfutils.isObjectNodeClass(nodeclass):
        shacl_rule['is_property'] = False
        relid = scan_entity(o, classtype, id, shacl_rule['optional'])
        if relid is not None:
            has_components = True
            full_attribute_name = utils.get_prefixed(context_graph, attributename)
            if instance.get(full_attribute_name) is None:
                instance[full_attribute_name] = []
            attr_instance = jsonld.get_ngsild_relationship(relid)
            if is_placeholder and datasetId is not None:
                attr_instance['datasetId'] = datasetId
            if debug:
                attr_instance['debug'] = \
                    f'{full_attribute_name}, {str(node)}'
            instance[full_attribute_name].append(attr_instance)
            shacl_rule['contentclass'] = classtype
            minshaclg.copy_property_from_shacl(shaclg, instance['type'], attributename)
        if not shacl_rule['optional']:
            has_components = True
            shacl_rule['contentclass'] = classtype
    elif rdfutils.isVariableNodeClass(nodeclass):
        shacl_rule['is_property'] = True
        shaclg.get_shacl_iri_and_contentclass(g, o, node, shacl_rule)
        full_attribute_name = utils.get_prefixed(context_graph, attributename)
        try:
            value = next(g.objects(o, basens['hasValue']), None)
            if value is None:
                value = next(g.objects(o, basens['hasValueList']), None)
            if value is not None:
                if not shacl_rule['is_iri']:
                    value = jsonld.get_value(g, value, shacl_rule['datatype'])
                else:
                    value = e.get_contentclass(shacl_rule['contentclass'], value)
                    value = value.toPython()
            else:
                if not shacl_rule['is_iri']:
                    if shacl_rule['isAbstract']:
                        warnmsg = f"Abstract OPCUA DataType \
    {str(shacl_rule.get('orig_datatype'))} in instance attribute {attributename} \
    found without concreate value in {node}."
                        print_warning('abstract_datatype', warnmsg)
                    value = jsonld.get_default_value(shacl_rule['datatype'],
                                                     shacl_rule.get('orig_datatype'),
                                                     shacl_rule.get('value_rank'),
                                                     shacl_rule.get('array_dimensions'), g=g)
                else:
                    value = e.get_default_contentclass(shacl_rule['contentclass'])
        except Exception as error:
            print("Error:", error)
        has_components = True
        if not shacl_rule['is_iri']:
            instance[f'{full_attribute_name}'] = \
                jsonld.get_ngsild_property(value, datatype=shacl_rule['datatype'])
        else:
            if value is None:
                value = NULL_IRI
                warnmsg = f"IRI value is not found for {full_attribute_name} in node {node}. \
Check whether it has a proper type definition. Most likely this attribute is not defined in the type definition."
                print_warning('no_iri_value', warnmsg)
            instance[f'{full_attribute_name}'] = jsonld.get_ngsild_property(value, isiri=True)
        if type is not None:
            minshaclg.copy_property_from_shacl(shaclg, type, full_attribute_name)
        if debug:
            instance[f'{full_attribute_name}']['debug'] = \
                f'{full_attribute_name}, {str(node)}'
        try:
            is_updating = bool(next(g.objects(o, basens['isUpdating'])))
        except:
            is_updating = False
        if (is_updating or not minimal_shacl) and not is_property:
            bindingsg.create_binding(g, URIRef(node_id), o, attributename)
        attributes = scan_entity_variable(o, classtype, id, shacl_rule['optional'])
        utils.merge_attributes(instance[f'{full_attribute_name}'], attributes)
    return has_components


def scan_entity_nonrecursive(node, id, instance, node_id, o, generic_reference=None):
    has_components = False
    shacl_rule = {}
    nodeclass, classtype = rdfutils.get_type(g, o)
    attributename = rdfutils.get_semantic_bridge(g, node, o)
    prefixed_attribute_name = utils.get_prefixed(context_graph, attributename)
    shacl_rule['path'] = entity_namespace[attributename]

    if generic_reference is not None:
        prefixed_attribute_name = g.qname(generic_reference)
    if rdfutils.isObjectNodeClass(nodeclass):
        shacl_rule['is_property'] = False
        relid = rdfutils.generate_node_id(g, rootentity, o, id)
        if relid is not None:
            has_components = True
            if prefixed_attribute_name not in instance:
                instance[prefixed_attribute_name] = []
            toappend = jsonld.get_ngsild_relationship(relid)
            non_followed_nodes.add(o)
            if debug:
                toappend['debug'] = prefixed_attribute_name
            instance[prefixed_attribute_name].append(toappend)
            shacl_rule['contentclass'] = classtype
    elif rdfutils.isVariableNodeClass(nodeclass):
        print(f"Warning: Variable node {o} is target of non-owning reference {prefixed_attribute_name}. \
This will be ignored.")
    return has_components


if __name__ == '__main__':

    args = parse_args()
    instancename = args.instance
    rootinstancetype = args.type
    jsonldname = args.jsonld
    entitiesname = args.entities
    shaclname = args.shacl
    bindingsname = args.bindings
    contextname = args.context
    debug = args.debug
    namespace_prefix = args.namespace
    entity_id = args.id
    minimal_shacl = args.minimalshacl
    maximal_shacl = args.maximalshacl
    context_url = args.context_url
    entity_namespace = args.entity_namespace
    parse_properties = args.properties
    value_rank_subshapes_enabled = args.value_rank_subshapes

    # create the context_graph
    # Context graph is resolving the context_url and provides just the
    # namespace manager
    context_graph = libjsonld.get_context_namespaces(context_url)

    # set filter for warning suppressions
    for warnstr in args.suppress_warnings or []:
        message = f"{warnstr}.*"
        warnings.filterwarnings("ignore", message=message)
    if minimal_shacl and maximal_shacl:
        print("--minimalshacl and --maximalshacl are mutual exclusive")
        exit(1)
    entity_namespace = Namespace(f'{namespace_prefix}entity/') if entity_namespace is None else entity_namespace
    shacl_namespace = Namespace(f'{namespace_prefix}shacl/')
    binding_namespace = Namespace(f'{namespace_prefix}bindings/')
    g = Graph(store='Oxigraph')
    g.parse(instancename)
    # get all owl imports
    mainontology = next(g.subjects(RDF.type, OWL.Ontology))
    imports = g.objects(mainontology, OWL.imports)
    if args.recursive_import:
        ontology_loader = OntologyLoader(True)
        ontology_loader.init_imports(imports)
        g += ontology_loader.get_graph()
    else:
        for imprt in imports:
            h = Graph(store="Oxigraph")
            print(f'Importing ontology {imprt}')
            h.parse(imprt)
            g += h
            for k, v in list(h.namespaces()):
                if k != '':
                    g.bind(k, v)

    types = []
    basens = next(Namespace(uri) for prefix, uri in list(g.namespaces()) if prefix == 'base')
    opcuans = next(Namespace(uri) for prefix, uri in list(g.namespaces()) if prefix == 'opcua')
    bindingsg = Bindings(namespace_prefix, basens)
    bindingsg.bind('base', basens)
    bindingsg.bind('binding', binding_namespace)
    shaclg = Shacl(g, namespace_prefix, basens, opcuans, value_rank_subshapes_enabled=value_rank_subshapes_enabled)
    shaclg.bind('shacl', shacl_namespace)
    shaclg.bind('ngsi-ld', ngsildns)
    shaclg.bind('sh', SH)
    shaclg.bind('base', basens)
    minshaclg = Shacl(g, namespace_prefix, basens, opcuans)
    minshaclg.bind('shacl', shacl_namespace)
    minshaclg.bind('ngsi-ld', ngsildns)
    minshaclg.bind('sh', SH)
    minshaclg.bind('base', basens)
    e = Entity(namespace_prefix, basens, opcuans)
    e.bind('base', basens)
    e.bind('example', utils.EX)
    e.bind('ngsi-ld', ngsildns)
    rdfutils = RdfUtils(basens, opcuans)
    e.create_ontolgoy_header(entity_namespace)
    for k, v in list(g.namespaces()):
        e.bind(k, v)
        shaclg.bind(k, v)

    jsonld = JsonLd(basens, opcuans)
    result = g.query(query_namespaces, initNs={'base': basens, 'opcua': opcuans})
    for uri, prefix, _ in result:
        e.bind(prefix, Namespace(uri))
    ignored_references = rdfutils.get_ignored_references(g)
    ignored_hierarchical_references = []
    if not parse_properties:
        ignored_hierarchical_references.append(opcuans['HasProperty'])

    # First scan the templates to create the rules
    # If there is a rootinstancetype defined, use it. Otherwise,
    # check if there is a machinery folder
    rootentity = None
    instancetypes = None
    if rootinstancetype is None:
        machinery_nodes_and_types = rdfutils.get_machinery_nodes(g)
        if machinery_nodes_and_types is None:
            print("Error: root-instance could not be determined. Neither type given explicitly (via -t) nor a \
Machinery Folder was found in instance ontology.")
            exit(1)
        rootentity = machinery_nodes_and_types[0][0]
        rootinstancetype = machinery_nodes_and_types[0][1]
        if maximal_shacl:
            # Get all types which stem from objects in the entity namespace
            instancetypes = rdfutils.get_object_types_from_namespace(g, mainontology)
        else:
            instancetypes = [rootinstancetype]
    if rootinstancetype is not None:
        try:
            root = next(g.subjects(basens['definesType'], URIRef(rootinstancetype)))
        except:
            print(f"Error: root-instance with type {rootinstancetype} not found. Please review the type parameter.")
            exit(1)
        if instancetypes is None:
            instancetypes = [URIRef(rootinstancetype)]
    for instancetype in instancetypes:
        print(f"Scanning type: {instancetype}")
        root = next(g.subjects(basens['definesType'], URIRef(instancetype)))
        scan_type(root, instancetype)
    # Then scan the entity with the real values
    if rootentity is None:
        rootentity = next(g.subjects(RDF.type, URIRef(rootinstancetype)), None)
    if rootentity is None:
        print(f"The provided type {rootinstancetype} could not be found in this ontology.")
        exit(1)
    entity_id = f'{entity_id}' if entity_id is not None else None
    non_followed_nodes = set()
    followed_nodes = set()
    scan_entity(rootentity, URIRef(rootinstancetype), entity_id)
    # Check if nodes from non-hierarchical references are left-out
    for node_id in non_followed_nodes.difference(followed_nodes):
        _, type = rdfutils.get_type(g, node_id)
        scan_entity(node_id, type, entity_id)
    # Did we catch all? If not, give warning
    if len(non_followed_nodes.difference(followed_nodes)) > 0:
        warnstr = "Some nodes referenced by non-hierarchical references are not \
added. This will potentially create validation issues."
        print_warning('non_reached_nodes', warnstr)
    # Add types to entities
    for type in types:
        e.add_subclass(type)
    jsonld.serialize(jsonldname)
    # Add all subclassing to entities
    if entitiesname is not None:
        result = g.query(query_subclasses)
        e.add_subclasses(result)
        e.serialize(destination=entitiesname)
    if shaclname is not None:
        shaclg.serialize(destination=shaclname)
        minshaclg.serialize(destination=f'min_{shaclname}')
    entities_ns = utils.extract_namespaces(e.get_graph())
    shacl_ns = utils.extract_namespaces(shaclg.get_graph())
    combined_namespaces = {**entities_ns, **shacl_ns}
    final_namespaces = {}
    for key, value in combined_namespaces.items():
        final_namespaces[key] = value
    jsonld.dump_context(contextname, final_namespaces)
    if bindingsg.len() > 0:
        bindingsg.serialize(destination=bindingsname)
